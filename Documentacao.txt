Aqui vamos receber os numeros:
- converte-los em inteiros
- checar se sao numeros
- se ha espacos demasiados
- se ha repetidos --> nesse caso, retornaremos um erro;
- verificar se ja esta sorted (return Zero comandos para ordenar)

Examples of possible arguments:
INT_MAX -> 2147483647
INT_MIN -> -2147483648

./push_swap "   -1-2" 1 2 3 --> -1, -2, 1, 2, 3  (check)

./push_swap "  1 2 3 -" --> erro (check)

./push_swap "-1 -  " --> erro   (check)

./push_swap " 1 -a 2" --> erro (check)

./push_swap "    1 " 2 3 --> 1, 2, 3 (check)

./push_swap 1 2 3 (check)

./push_swap " 1  2  3" (check)

./push_swap "-8-9" --> -8, -9

gcc -fsanitize=address count_words.c -g -o split_rec

"1 2 3 4    4  5 6      6"

dia 07 de fevereiro
	(0k)--> Consegui fazer meu argumento receber tanto argumentos
organizados quanto argumentos separados por espacos dentro
de aspas.
	(0k)--> Preciso agora evitar que seja adicionado valores repetidos.
Caso o valor tratado ja esteja na lista deveremos retornar erro.
Acredito que resolverei isso dentro da minha funcao de insert_end,
pois vamos percorrer a lista comparando os valores.
	(0k)--> Preciso fazer meu codigo aceitar valores negativos. Contudo, ao
criar um documento learning.c o problema nao estava nem no meu atoi nem
no meu insert_end. Avaliando a situacao percebi que o meu codigo esta
adicionando de forma repetida os valores negativos. Por isso, ele nao
consegue adiciona-los.
	(0k)--> preciso perceber se a lista ja esta "sorted"
	(0k)--> eu preciso lidar com o menor integer de todos;


	--> quando eu introduzo -2147483648 meu output e de correto. Contudo,
	quando eu introduzo 2147483648 meu output e de -2147483648.
	--> preciso fazer os movimentos
	--> preciso comecar a organizar qual sera o algoritmo que usarei
	midpoint algorithm;


no subject do projeto falou em: duplicated, integers, bigger than int,

- Instructions must be separated by a ’\n’ and nothing else.
- If no parameters are specified, the program must not display anything and give the
prompt back
